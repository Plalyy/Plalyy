# 操作系统

## 孤儿进程、僵尸进程、守护进程
- 孤儿进程：父进程退出，还在运行的子进程成为孤儿进程。被init（1号进程）收养并完成wait或waitpid状态手机工作。
- 僵尸进程：进程使用fork创建子进程后，子进程退出而父进程没有wait或waitpid获取子进程状态信息。那么子进程的进程描述符仍然保存在系统中，成为僵尸进程。
- 守护进程：后台运行的特殊进程，执行特定的系统任务。很多在系统引导的时候启动，并运行到系统关闭。一些需要的时候才启动，完成任务后自动结束。创建守护进程，setsid。系统守护进程：syslogd、login、crond、at等。 网络守护进程：sendmail、httpd、xinetd、等。 独立启动的守护进程：httpd、named、xinetd等。 被动守护进程（由xinetd启动）：telnet、finger、ktalk等。
  - 创建守护进程方法：
    - 1 创建子进程，退出父进程（确保当前不是进程组组长，孤儿进程被init收养）  
    - 2 子进程setsid创建新的会话 （成为新会话首进程，新进程组组长，断开中断连接）
    - 3 调用chdir，更改当前工作目录为根目录（守护进程存在时，无法卸载工作目录） 
    - 4 调用umask，修改文件权限掩码（便于守护进程创建文件）
    - 5 调用close，关闭打开的文件描述符号。
## Linux终端
- 进程，多个进程->进程组，多个进程组->会话，进程组和会话是为了支持shell作业控制而引入的概念。
- 登录Linux时，为用户此案件会话，登录进程是首进程，首进程ID作为整个会话的ID。会话是一个或多个进程组的集合，囊括了登录用户的所有活动。在登录shell时，用户可能会使用管道，让多个进程互相配合完成一项工作，这一组进程属于同一个进程组。
- 通常，会话开始于用户登录，终止于用户退出，期间的所有进程都属于这个会话。一个会话一般包含一个会话首进程、一个前台进程组和一个后台进程组，控制终端可有可无；此外，前台进程组只有一个，后台进程组可以有多个，这些进程组共享一个控制终端。
- 前台进程组：该进程组中的进程可以向终端设备进行读、写操作（属于该组的进程可以从终端获得输入）。该进程组的 ID 等于控制终端进程组 ID，通常据此来判断前台进程组。
- 后台进程组：会话中除了会话首进程和前台进程组以外的所有进程，都属于后台进程组。该进程组中的进程只能向终端设备进行写操作
## 父子进程
- Linux除了内核启动进程外，其他进程都由父进程fork产生，通过pid识别进程
- 父进程通过fork创建子进程，调用成功返回两次：返回值为0代表当前为子进程，为非负数代表是父进程，调用失败返回-1
- fork后，内核分配新进程ID，然后分配进程空间。将父进程数据段、堆栈段（虚拟地址空间上父子进程，数据段与堆栈段不同，但实际物理地址相同。只有子进程开始修改父进程的数据段、堆栈段时，才会分配新物理地址空间，写时复制）代码段父子进程共享，共享代码段。父子进程共享页帧，所以页帧不能被修改，被保护（只读）
- 库函数exit(终止进程)，归还内核，参数为整形变量，标识推出状态。父进程用wait()获取状态，exit时库函数，位于_exit()之上。
## 线程、进程、协程
### 概念
- 进程：系统进行资源分配和调度的基本单位。
- 线程：线程是进程的一个实体，是CPU调度和分派的基本单位。自己的资源：栈（参数、返回地址等）、PC（程序计数器）、TLS（线程本地存储，存独有的数据）
- 协程：有独立上下文，切换由自己控制，由当前协程切换到其他协程由当前协程控制

协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。协程是一种用户态线程，切换只发生在用户态，并且切换时机由用户程序控制，所有的切换都是有效切换，而且协程的上下文数据小。
- 多线程：对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。不利于资源的管理和保护
- 多进程：进程有独立的地址空间，多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些
切换
- 进程上下文切换
  - 进程id
  - 状态
  - 优先级
  - 权限
  - 内存（数据段和堆）
  - 栈
  - 指向可执行程序文件的描述符
  - 打开的文件描述符
  - 寄存器
  - 程序I/O状态
- 线程上下文切换
  - 状态
  - 优先级
  - 栈
  - 寄存器
- 协程的上下文切换
  - 栈
  - 寄存器

进程间通信
- 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
- 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
- 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。
- 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

线程间通信
- 共享内存：线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式通信。

volatile共享内存
- 消息传递：线程之间没有公共的状态，线程之间必须通过明确的发送信息来显示的进行通信。生产者消费者模型

wait/notify等待通知方式 

join方式
- 管道流

管道输入/输出流的形式

栈为什么比堆块
- 申请速度块：栈基本是是程序运行前（编译）就已经分配好的空间，而堆在运行时动态申请，动态分配速度和分配算法、机器运行速度有关。 好像也可以运行时分配栈。
- 存储寻址速度快：栈的物理地址空间连续，而堆不一定
- CPU硬件操作速度快：cpu专门寄存器esp、ebp操作栈，而堆间接寻址

Linux文件系统的数据结构
- Linux树形结构，最上层是根目录
- Linux的虚拟文件系统允许众多不同类型的文件系统共存，并支持跨文件系统的操作。
- Linux的文件是无结构字符流式文件，不考虑文件内部的逻辑结构，只把文件简单地看作是一系列字符的序列。
- Linux的文件可由文件拥有者或超级用户设置相应的访问权限而受到保护。
- Linux把所有的外部设备都看作文件，可以使用与文件系统相同的系统调用来读写外部设备

软连接和硬链接
- 硬链接是建立副本，inode计数+1
- 软连接是映射到源文件名，inode计数不变

线程同步：同进程的多线程协调工作达到一致性
- 两种情况：线程同步和线程互斥

方法：
- 信号量：信号量是维护0到指定最大值之间的同步对象。信号量状态在其计数大于0时是有信号的，而其计数是0时是无信号的。信号量对象在控制上可以支持有限数量共享资源的访问。
- 互斥量
- 事件
- 临界区
内核态和用户态

当作两种权限等级
- 切换方式
  - 系统调用：软件中断（和硬件中断不同）
  - 异常：当前进程异常，切换到处理该异常的内核相关进程
  - 外围设备中断：外围设备完成用户请求操作后，向CPU发送中断信号，切换对应中断处理程序。
- 切换过程
  - 设置处理器至内核态
  - 保存当前寄存器（栈指针、程序计数器、通用寄存器）
  - 将栈指针设置指向内核栈地址
  - 将程序计数器设置为一个事先约定的地址，存放系统调用处理程序的起始地址
- 避免频繁切换
  - 减少线程切换：线程切换会导致用户态和内核态的切换
    - 无锁并发：多线程竞争锁，导致较多上下文切换。synchronized通过监视器锁实现，以来OS底层Mutex Lock实现，需要线程挂起并切换到内核态。重量级锁
    - CAS算法
    - 使用最少的线程
    - 协程：单线程执行多任务的调度和切换
- 减少内核态和用户态切换
  - 使用用户进程缓冲区（buffer， read）和内核缓存区

Linux系统如何启动
- 内核的引导。
- 运行 init。
- 系统初始化。
- 建立终端 。
- 用户登录系统。

线程资源
- 共享的资源
  - 堆：堆是进程空间中开辟的，new出来的都是共享
  - 全局变量
  - 静态变量：存于堆中开辟的.bss段和.data段，共享
  - 文件等公用资源
- 独享的资源
  - 线程ID：标识线程
  - 栈：堆栈？
  - 错误返回码、信号屏蔽码
  - 寄存器：线程存放副本，包括程序计数器PC
  - 线程优先级

深拷贝和浅拷贝
- 浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，
- 深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，

## 虚拟内存

内存管理技术，每个进程有独立的虚拟地址空间，进程访问的虚拟地址空间并不是真正的物理地址
虚拟地址可通过每个进程上页表与物理地址进行映射，获得真正的物理地址
如果虚拟地址所对应的物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；如果此时物理内存已经耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中。

MMU、TLB
- MMU硬件，将虚拟地址转换为物理地址
- TLB快表，查看MMU最近访问的内容

地址方向 大端小端
- 大端是把字符串的尾端数据存在内存高地址处；
- 小端是把字符串的尾端数据存在内存的低地址处。

信号和信号量
- 信号：处理异步事件的方式，是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。
- 信号量：进程间通信处理同步互斥的机制，在多线程环境下使用，负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。 


【todo】Linux系统运行缓慢，用什么命令查看

【todo】中断

熟悉的gcc选项

-l链接  -i搜索 

通过进程名找到pid，查看进程的函数调用栈，如何调试程序

在进程崩掉后如何追踪日志，CPU和内存占用过高时如何定位问题，gdb怎么样打印调用栈

动态映射区

如何编写cache友好的代码

找出占用80端口的进程？ 

netstat -nlp | grep 80 

锁怎么实现？ 硬件锁机制，自旋锁CAS，mutex睡眠等待唤醒，rcu锁机制

Linux下查看符号表命令、查看端口占用命令、查看进程打开的文件命令：nm， netstat，lsof

O1，O2，O3有什么区别，分别优化了那些？

linux进程调度的调度算法，用到的数据结构（关于到底是红黑树还是堆）
   linux分配堆内存的算法？   linux物理内存换页的算法？

用户空间申请信号量的时候，是如何陷入到内核空间的

内存栅栏是什么？

自旋锁、乐观锁、悲观锁区别？

linux命令的使用，如何查看系统内存占用、处理器配置、root下的几个文件夹
死锁

fork做了什么事  fork时页表拷贝有哪几种方式

exec

怎么看虚拟内存

vmstat命令

内核申请64M内存以上该怎么做

操作系统的内存分布

top的used、free memory那些了解吗

64位操作系统和32位相比有什么优势, Linux设计的虚拟内存有什么用

cache 映射方式

IO模型 网络IO模型有几种，分别是什么

IO多路复用相关

进程调度算法了解什么？介绍一下O(1)和CFS？

一个可执行程序是如何运行起来的


mmap

内存管理

文件系统，比如write系统调用

某个命令很慢，怎么排查 （看是否后台进程占用太多资源？）

如何查看CPU、内存 （top，free，还有啥吗）

用过哪些Linux命令

tail，less，more，ls，top，ps， netstat， nohup， ln， mkdir， mv， scp， tmux，

两个文件 输出两个文件中不同行（操作系统）

操作系统有那些cache分别是做什么的？

page cache , buffer cache , swap cache。

内存分页、分段

os内存伙伴算法

进程有哪几种状态？如何切换的

Linux怎么查看负载

Linux的负载主要和CPU使用、内存使用、IO消耗三部分有关。

w或uptime展示负载，load average分别对应过去1分钟，5分钟，15分钟负载平均值。


top命令清晰展现出系统的状态，实时监控，按q退出。

【todo】GDB

查看指针地址和值指令？

查看调用栈指令？

怎么打断点？

线程安全（i++）
- 多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。 进程安全则是对于共享的变量或文件。
- 实现线程安全
  - 锁

全双工，半双工

讲一讲synchronized底层实现

热点数据怎么来理解和定义

虚拟地址空间->物理地址映射？系统级还是进程级的 

Linux命令nm

I/O多路复用：select, poll, epoll

CPU cache分几种

Linux内核，文件的read，write时发生了什么

指令重排序什么时候发生？ 

